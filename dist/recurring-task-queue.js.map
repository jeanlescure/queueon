{
  "version": 3,
  "sources": ["../src/index.ts", "../src/interfaces.ts"],
  "sourcesContent": ["import {\n  RTQEvent,\n  RTQQueueEntry,\n  RTQStatusEnum,\n  RTQActionEnum,\n  RTQTask,\n  RTQTaskHandler,\n} from \"./interfaces\";\n\n// @ts-ignore\nimport { version } from '../package.json';\n\nexport * from \"./interfaces\";\n// @ts-ignore\nexport { version } from '../package.json';\n\nexport const RTQStatus = { ...RTQStatusEnum };\nexport const RTQAction = { ...RTQActionEnum };\n\n\nlet ShortUniqueId: any;\n\nif (typeof window !== 'undefined')  {\n  ShortUniqueId = (window as any).ShortUniqueId;\n} else {\n  ShortUniqueId = require('short-unique-id');\n}\n\ntype RTQCustomErrorHandler = (error: any) => Promise<void>;\n\ninterface RTQOptions {\n  fetchTasks: () => Promise<RTQTask<unknown>[]>;\n  updateTask: (task: RTQTask<unknown>) => Promise<void>;\n  createQueueEntry: (queueEntry: RTQQueueEntry) => Promise<void>;\n  fetchQueueEntries: () => Promise<RTQQueueEntry[]>;\n  removeQueueEntry: (queueEntry: RTQQueueEntry) => Promise<void>;\n  taskHandlers: {[k: string]: RTQTaskHandler<unknown>};\n  eventHandler: (event: RTQEvent) => Promise<void>;\n  errorHandler?: RTQCustomErrorHandler;\n  maxConcurrentTasks?: number;\n}\n\nconst defaultOptions: Partial<RTQOptions> = {\n  maxConcurrentTasks: 0,\n  errorHandler: async (e) => console.log(e),\n}\n\nexport default class RTQ {\n  static RTQStatus = RTQStatus;\n  static version = version;\n\n  options: RTQOptions;\n  runningTasks: number = 0;\n  uid: any;\n  ticking: boolean = false;\n  \n  constructor(options: RTQOptions) {\n    this.options = {\n      ...defaultOptions,\n      ...options,\n    };\n\n    this.uid = new ShortUniqueId();\n  }\n\n  async modifyTaskStatus({\n    task,\n    status,\n    reason,\n    triggeredBy,\n    retryCount,\n    lastRun,\n  }: {\n    task: RTQTask<unknown>;\n    status: RTQStatusEnum;\n    reason?: string;\n    triggeredBy?: string;\n    retryCount?: number;\n    lastRun?: Date;\n  }) {\n    const {\n      options: {\n        updateTask,\n        eventHandler,\n        errorHandler,\n      },\n    } = this;\n\n    const updatedTask = {\n      ...task,\n      status,\n      retryCount: retryCount || task.retryCount,\n      lastRun: lastRun || task.lastRun,\n    };\n\n    return await updateTask(updatedTask)\n      .then(() => {\n        eventHandler({\n          timestamp: new Date(),\n          action: RTQAction.MODIFY_TASK_STATUS,\n          message: `changed status of ${task.taskName} to ${status}`,\n          reason: reason || '',\n          additionalData: {\n            taskId: task.id,\n            taskName: task.taskName,\n            prevStatus: task.status,\n            status,\n          },\n          triggeredBy: triggeredBy || 'RTQ',\n        }).catch(errorHandler);\n\n        return updatedTask;\n      })\n      .catch((e) => {\n        (errorHandler as RTQCustomErrorHandler)(e);\n\n        eventHandler({\n          timestamp: new Date(),\n          action: RTQAction.MODIFY_TASK_STATUS,\n          message: `failed changing status of ${task.taskName} to ${status}`,\n          reason: reason || '',\n          additionalData: {\n            taskId: task.id,\n            taskName: task.taskName,\n            prevStatus: task.status,\n            status,\n          },\n          triggeredBy: triggeredBy || 'RTQ',\n        }).catch(errorHandler);\n\n        return null;\n      });\n  }\n\n  async queueTask(\n    task: RTQTask<unknown>,\n    index: number,\n    taskArray: RTQTask<unknown>[]\n  ) {\n    const {\n      options: {\n        createQueueEntry,\n        eventHandler,\n        errorHandler,\n      },\n    } = this;\n\n    const queryEntry: RTQQueueEntry = {\n      id: this.uid.stamp(16),\n      taskId: task.id,\n      queuedAt: new Date(),\n    };\n\n    const result = await createQueueEntry(queryEntry).then(() => {\n      eventHandler({\n        timestamp: new Date(),\n        action: RTQAction.MODIFY_QUEUE,\n        message: `added queue entry ${queryEntry.id} to queue`,\n        reason: 'tick',\n        additionalData: queryEntry,\n        triggeredBy: 'RTQ',\n      }).catch(errorHandler);\n    }).catch(\n      (e) => {\n        (errorHandler as RTQCustomErrorHandler)(e);\n        return null;\n      }\n    );\n\n    if (result === null) {\n      return null;\n    }\n\n    return await this.modifyTaskStatus({\n      task,\n      status: RTQStatus.QUEUED,\n    });\n  }\n\n  async processTask(\n    task: RTQTask<unknown>,\n    index: number,\n    taskArray: RTQTask<unknown>[]\n  ) {\n    this.runningTasks += 1;\n\n    const {\n      taskName,\n      taskOptions,\n      lastRun,\n      waitTimeBetweenRuns,\n      retryCount: taskRetryCount,\n      maxRetries,\n    } = task;\n\n    const msSinceLastRun = (Date.now().valueOf() - lastRun.valueOf());\n\n    if (msSinceLastRun < waitTimeBetweenRuns) {\n      await this.modifyTaskStatus({\n        task: task,\n        status: RTQStatus.AWAITING_RETRY,\n      });\n\n      return;\n    }\n\n    const {\n      options: {\n        taskHandlers,\n        errorHandler,\n      },\n    } = this;\n\n    let status = RTQStatus.INITIATED;\n    let retryCount = taskRetryCount;\n\n    if (retryCount > 0) {\n      status = RTQStatus.RETRIED;\n    }\n\n    let upToDateTask: RTQTask<unknown> | null = task;\n\n    upToDateTask = await this.modifyTaskStatus({\n      task: upToDateTask,\n      status,\n      retryCount,\n    });\n\n    if (upToDateTask === null) {\n      return;\n    }\n\n    upToDateTask = await this.modifyTaskStatus({\n      task: upToDateTask,\n      status: RTQStatus.IN_PROGRESS,\n      lastRun: new Date(),\n    });\n\n    if (upToDateTask === null) {\n      return;\n    }\n\n    taskHandlers[taskName](taskOptions)\n      .then(async () => {\n        upToDateTask = await this.modifyTaskStatus({\n          task: (upToDateTask as RTQTask<unknown>),\n          status: RTQStatus.SUCCEEDED,\n          retryCount: 0,\n        });\n      })\n      .catch(async (e) => {\n        if (errorHandler) {\n          errorHandler(e).catch(console.log);\n        }\n\n        let status = RTQStatus.AWAITING_RETRY;\n\n        if (retryCount >= maxRetries) {\n          status = RTQStatus.FAILED;\n        }\n\n        retryCount += 1;\n\n        upToDateTask = await this.modifyTaskStatus({\n          task: (upToDateTask as RTQTask<unknown>),\n          status,\n          retryCount,\n          reason: e.message || JSON.stringify(e),\n        });\n      })\n      .finally(() => {\n        this.runningTasks -= 1;\n      });\n  }\n\n  async tick() {\n    if (this.ticking) {\n      return;\n    }\n\n    this.ticking = true;\n\n    const {\n      options: {\n        fetchTasks,\n        fetchQueueEntries,\n        removeQueueEntry,\n        maxConcurrentTasks,\n        eventHandler,\n        errorHandler,\n      }\n    } = this;\n\n    let tasks = await fetchTasks().catch(errorHandler) as RTQTask<unknown>[];\n\n    if (!Array.isArray(tasks)) {\n      return;\n    }\n\n    const queueEntries = await fetchQueueEntries().catch(errorHandler);\n\n    if (!Array.isArray(queueEntries)) {\n      return;\n    }\n\n    const filteredEntries = queueEntries.sort((a, b) => {\n      return (new Date(b.queuedAt).getTime()) - (new Date(a.queuedAt).getTime());\n    }).reduce((a, b) => {\n      if (maxConcurrentTasks === 0 || a.length < (maxConcurrentTasks as number)) {\n        a.push(b);\n      }\n\n      return a;\n    }, [] as RTQQueueEntry[]);\n\n    await Promise.all(\n      filteredEntries.map(\n        async (q) => await removeQueueEntry(q).then(() => {\n          eventHandler({\n            timestamp: new Date(),\n            action: RTQAction.MODIFY_QUEUE,\n            message: `removed queue entry ${q.id} from queue`,\n            reason: 'tick',\n            additionalData: q,\n            triggeredBy: 'RTQ',\n          }).catch(errorHandler);\n        }).catch((e) => {\n          eventHandler({\n            timestamp: new Date(),\n            action: RTQAction.MODIFY_QUEUE,\n            message: `failed removing queue entry ${q.id} from queue`,\n            reason: e.message || JSON.stringify(e),\n            additionalData: {error: e},\n            triggeredBy: 'RTQ',\n          }).catch(errorHandler);\n\n          (errorHandler as RTQCustomErrorHandler)(e);\n        })\n      )\n    ).catch(errorHandler);\n\n    const tasksReadyToProcess = filteredEntries.map(\n      (qe) => tasks.find((t) => t.id === qe.taskId)\n    );\n\n    const numOfTasksProcessed = tasksReadyToProcess.length;\n\n    (tasksReadyToProcess as RTQTask<unknown>[]).forEach(\n      (t, i, a) => this.processTask(t, i, a)\n    );\n\n    tasks = await fetchTasks().catch(errorHandler) as RTQTask<{}>[];\n\n    if (!Array.isArray(tasks)) {\n      return;\n    }\n\n    const tasksToBeQueued = tasks.filter(\n      (t) => (\n        (tasksReadyToProcess as RTQTask<unknown>[]).findIndex((tp) => t.id === tp.id) < 0\n      )\n    ).filter(\n      (t) => (\n        t.status === RTQStatus.NEW\n        || t.status === RTQStatus.AWAITING_RETRY\n        || t.status === RTQStatus.SUCCEEDED\n      )\n    );\n\n    await Promise.all(\n      tasksToBeQueued.map(\n        async (t, i, a) => await this.queueTask(t, i, a).catch(\n          (e) => {\n            (errorHandler as RTQCustomErrorHandler)(e);\n            return null;\n          }\n        )\n      )\n    ).then((a) => {\n      this.ticking = false;\n\n      if (\n        numOfTasksProcessed < 1\n        && tasksToBeQueued.length > 0\n        && !a.includes(null)\n      ) {\n        this.tick();\n      }\n    }).catch(errorHandler);\n  }\n}\n", "type milliseconds = number;\n\nexport type RTQTaskId = string;\n\nexport enum RTQStatusEnum {\n  NEW = 'NEW',\n  QUEUED = 'QUEUED',\n  INITIATED = 'INITIATED',\n  RETRIED = 'RETRIED',\n  IN_PROGRESS = 'IN_PROGRESS',\n  FAILED = 'FAILED',\n  AWAITING_RETRY = 'AWAITING_RETRY',\n  AWAITING_NEXT_RUN = 'AWAITING_NEXT_RUN',\n  SUCCEEDED = 'SUCCEEDED',\n}\n\nexport interface RTQTask<O extends unknown> {\n  id: RTQTaskId;\n  status: RTQStatusEnum;\n  waitTimeBetweenRuns: milliseconds;\n  taskName: string;\n  maxRetries: number;\n  retryCount: number;\n  lastRun: Date;\n  taskOptions: O;\n}\n\nexport interface RTQQueueEntry {\n  id: string;\n  taskId: RTQTaskId;\n  queuedAt: Date;\n}\n\nexport enum RTQActionEnum {\n  MODIFY_TASK_STATUS = 'MODIFY_TASK_STATUS',\n  MODIFY_QUEUE = 'MODIFY_QUEUE',\n}\n\nexport interface RTQEvent {\n  timestamp: Date;\n  action: RTQActionEnum;\n  message: string;\n  reason: string;\n  additionalData: {[k: string]: any};\n  triggeredBy: string;\n}\n\nexport type RTQTaskHandler<O extends unknown> = (taskOptions: O) => Promise<void>;\n"],
  "mappings": "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",
  "names": []
}
