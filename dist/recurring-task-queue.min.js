var RTQ=(()=>{var Q=Object.defineProperty,U=Object.defineProperties;var C=Object.getOwnPropertyDescriptors;var N=Object.getOwnPropertySymbols;var _=Object.prototype.hasOwnProperty,x=Object.prototype.propertyIsEnumerable;var v=(n,e,t)=>e in n?Q(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,m=(n,e)=>{for(var t in e||(e={}))_.call(e,t)&&v(n,t,e[t]);if(N)for(var t of N(e))x.call(e,t)&&v(n,t,e[t]);return n},O=(n,e)=>U(n,C(e)),q=n=>Q(n,"__esModule",{value:!0});var S=(n=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(n,{get:(e,t)=>(typeof require!="undefined"?require:e)[t]}):n)(function(n){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+n+'" is not supported')});var H=(n,e)=>{q(n);for(var t in e)Q(n,t,{get:e[t],enumerable:!0})};var Y={};H(Y,{RTQAction:()=>p,RTQActionEnum:()=>E,RTQStatus:()=>d,RTQStatusEnum:()=>R,default:()=>D,version:()=>I});var R;(function(s){s.NEW="NEW",s.QUEUED="QUEUED",s.INITIATED="INITIATED",s.RETRIED="RETRIED",s.IN_PROGRESS="IN_PROGRESS",s.FAILED="FAILED",s.AWAITING_RETRY="AWAITING_RETRY",s.AWAITING_NEXT_RUN="AWAITING_NEXT_RUN",s.SUCCEEDED="SUCCEEDED"})(R||(R={}));var E;(function(t){t.MODIFY_TASK_STATUS="MODIFY_TASK_STATUS",t.MODIFY_QUEUE="MODIFY_QUEUE"})(E||(E={}));var I="1.0.1";var d=m({},R),p=m({},E),w;typeof window!="undefined"?w=window.ShortUniqueId:w=S("short-unique-id");var P={maxConcurrentTasks:0,errorHandler:async n=>console.log(n)},D=class{constructor(e){this.runningTasks=0;this.ticking=!1;this.options=m(m({},P),e),this.uid=new w}async modifyTaskStatus({task:e,status:t,reason:y,triggeredBy:c,retryCount:T,lastRun:i}){let{options:{updateTask:u,eventHandler:l,errorHandler:s}}=this,k=O(m({},e),{status:t,retryCount:T||e.retryCount,lastRun:i||e.lastRun});return await u(k).then(()=>(l({timestamp:new Date,action:p.MODIFY_TASK_STATUS,message:`changed status of ${e.taskName} to ${t}`,reason:y||"",additionalData:{taskId:e.id,taskName:e.taskName,prevStatus:e.status,status:t},triggeredBy:c||"RTQ"}).catch(s),k)).catch(g=>(s(g),l({timestamp:new Date,action:p.MODIFY_TASK_STATUS,message:`failed changing status of ${e.taskName} to ${t}`,reason:y||"",additionalData:{taskId:e.id,taskName:e.taskName,prevStatus:e.status,status:t},triggeredBy:c||"RTQ"}).catch(s),null))}async queueTask(e,t,y){let{options:{createQueueEntry:c,eventHandler:T,errorHandler:i}}=this,u={id:this.uid.stamp(16),taskId:e.id,queuedAt:new Date};return await c(u).then(()=>{T({timestamp:new Date,action:p.MODIFY_QUEUE,message:`added queue entry ${u.id} to queue`,reason:"tick",additionalData:u,triggeredBy:"RTQ"}).catch(i)}).catch(s=>(i(s),null))===null?null:await this.modifyTaskStatus({task:e,status:d.QUEUED})}async processTask(e,t,y){this.runningTasks+=1;let{taskName:c,taskOptions:T,lastRun:i,waitTimeBetweenRuns:u,retryCount:l,maxRetries:s}=e;if(Date.now().valueOf()-i.valueOf()<u){await this.modifyTaskStatus({task:e,status:d.AWAITING_RETRY});return}let{options:{taskHandlers:g,errorHandler:h}}=this,a=d.INITIATED,r=l;r>0&&(a=d.RETRIED);let o=e;o=await this.modifyTaskStatus({task:o,status:a,retryCount:r}),o!==null&&(o=await this.modifyTaskStatus({task:o,status:d.IN_PROGRESS,lastRun:new Date}),o!==null&&g[c](T).then(async()=>{o=await this.modifyTaskStatus({task:o,status:d.SUCCEEDED,retryCount:0})}).catch(async f=>{h&&h(f).catch(console.log);let A=d.AWAITING_RETRY;r>=s&&(A=d.FAILED),r+=1,o=await this.modifyTaskStatus({task:o,status:A,retryCount:r,reason:f.message||JSON.stringify(f)})}).finally(()=>{this.runningTasks-=1}))}async tick(){if(this.ticking)return;this.ticking=!0;let{options:{fetchTasks:e,fetchQueueEntries:t,removeQueueEntry:y,maxConcurrentTasks:c,eventHandler:T,errorHandler:i}}=this,u=await e().catch(i);if(!Array.isArray(u))return;let l=await t().catch(i);if(!Array.isArray(l))return;let s=l.sort((a,r)=>new Date(r.queuedAt).getTime()-new Date(a.queuedAt).getTime()).reduce((a,r)=>((c===0||a.length<c)&&a.push(r),a),[]);await Promise.all(s.map(async a=>await y(a).then(()=>{T({timestamp:new Date,action:p.MODIFY_QUEUE,message:`removed queue entry ${a.id} from queue`,reason:"tick",additionalData:a,triggeredBy:"RTQ"}).catch(i)}).catch(r=>{T({timestamp:new Date,action:p.MODIFY_QUEUE,message:`failed removing queue entry ${a.id} from queue`,reason:r.message||JSON.stringify(r),additionalData:{error:r},triggeredBy:"RTQ"}).catch(i),i(r)}))).catch(i);let k=s.map(a=>u.find(r=>r.id===a.taskId)),g=k.length;if(k.forEach((a,r,o)=>this.processTask(a,r,o)),u=await e().catch(i),!Array.isArray(u))return;let h=u.filter(a=>k.findIndex(r=>a.id===r.id)<0).filter(a=>a.status===d.NEW||a.status===d.AWAITING_RETRY||a.status===d.SUCCEEDED);await Promise.all(h.map(async(a,r,o)=>await this.queueTask(a,r,o).catch(f=>(i(f),null)))).then(a=>{this.ticking=!1,g<1&&h.length>0&&!a.includes(null)&&this.tick()}).catch(i)}};D.RTQStatus=d,D.version=I;return Y;})();
'undefined'!=typeof module&&(module.exports=RTQ.default),'undefined'!=typeof window&&(RTQ=RTQ.default);